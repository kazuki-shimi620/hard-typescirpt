# ブラウザ内のコンポーネント
- レンダリングエンジン
    - ウェブページの描画を主に責任とする
    - HTMLとCSSを解析してピクセルとして表示する
- Javascriptエンジン
    - Javascript実行環境
// いつDOMを構築するの?

# ブラウザのレンダリングの流れ
1. Loading
    - Download > get resources
        - HTML, CSS, JS, Image, Video, Audioなど
        - ネットワーク
            - HTTP/2, HTTP/3, QUIC
                1. URLのホスト解釈
                    - ホスト名を解析して、IPアドレスを取得する
                    - ノード間のデータのやり取りでパケットを送信し合う
                        - パケットは、IPヘッダーとデータを含む
                        - IPヘッダー
                            - パケットの長さ
                            - 送信元のIPアドレス
                            - 送信先のIPアドレス
                            - 誤り訂正用のチェックサム
                                - チェックサムとは、パケットの整合性を保証するための値
                                - パケットの内容をチェックして、整合性を保証する
                            - パケットは内容が壊れることがある
                            - 送信したパケットが途中で消失することもある
                            - パケットの送信順は入れ替わることがある
                            - パケットの送信速度はネットワークの帯域幅に依存する
                            - パケットは複製されることもある
                2. TCP接続確立
                    - TCPとはIPに対して以下の機能を付加するプロトコル
                        - 相手先に確実にデータが届いているかどうかを確認する
                        - データの欠損や破損を検知して再送する
                        - データの送信順を担保する
                    - TCPコネクション
                        - 相手のIPアドレスとポート番号を指定してコネクションを確率sする// どうやって???
                        - 3-way handshake
                            - クライアントは、サーバーに対して接続を要求するSYNパケットを送信する
                                - SYNとは、同期を確立するためのパケット
                                - SYN = 「会話を始めたい」
                                - Client:「通信したい。次に送るデータは 1001 番からね」
                                    - Seq(シーケンス番号) = 1000
                                    - SYN = 1
                                    - ACK = 0
                            - SYNを受け取ったサーバーは接続を許可するACKパケットを送信する
                                - SYN-ACKとは、同期を確立するためのパケット
                                - Server:「1000 まで届いたよ俺も通信したい。次は 5001 から送る」
                                    - Seq = 5000
                                    - ACK = 1001
                                    - SYN = 1
                            - SYN-ACKを受け取ったクライアントは接続を許可するACKパケットを送信する
                                - ACKとは、同期を確立するためのパケット
                                Client:「5000 まで届いた。準備OK」
                                    - ACK = 5001
                            - 通信の確立とは、
                                - 双方が
                                    - 相手の IP / Port
                                    - 次に期待する Seq 番号
                                    - ウィンドウサイズ
                                - を メモリに状態として保持
                    - TCPヘッダー
                        - パケットのデータの内部にある
                        - パケットの送信元と送信先のIPアドレスとポート番号(80, 443)を指定する
                        - ヘッダーの長さ
                        - シーケンス番号(インデックスみたいなもの)
                        - ACK番号(SYNの時はACK番号は0)
                        - チェックサム
                        - その他オプション
                3. TLSハンドシェイク
                    - SSL/TLSとは、暗号化するためのプロトコル
                        - クライアントとサーバーの認証機能
                            - サーバー証明書をクライアントが検証し接続相手があっているかの確認をする機能
                            - ブラウザには信頼済み公開鍵一覧を持っている
                            - 証明書は公開鍵と署名を含んでいる
                            - 証明書の署名は、公開鍵で暗号化されている
                            - 証明書の署名を検証することで、公開鍵を検証することができる
                            - 証明書はCAによって発行されている
                            - CAは信頼済み公開鍵を持っている
                            - CAの公開鍵はブラウザに事前に登録されている
                            - CAとは、信頼済み公開鍵を持っている第三者
                4. HTTPヘッダーの解析
                    - HTTPヘッダーは、HTTPプロトコルの仕様に基づいて解析される
                    - HTTP1.0ではTCP, TLSのハンドシェイクが破棄されていた
                    - HTTP1.1ではTCP, TLSのハンドシェイクが維持されていた(keep-aliveの設定をしている場合)
                        - keep-aliveは、TCP, TLSのハンドシェイクを維持する
                        - 維持とは上記のACK番号を維持するという行為で、
                            - つまり、TCP上では次のパケットが来たという認識になる(順番は保証されている)
                    - HTTP2ではTCP, keep-aliveの設定をしている場合、複数のresourceを同時に送信することができる
                        - HTTP2は、HTTP1.1をベースに、より高速な通信を可能にする
                        - イメージ
                            - Stream 1: frame1 → frame2 → frame3
                            - Stream 3: frame1 → frame2
                    - 問題の発生とし整理
                        1. HTTP/1.1ではフレームという概念が実質1つだった
                        2. HTTP/2で複数フレーム（=複数streamの断片）を扱うようになった
                        3. TCPは“バイト列の順序が完全に揃わない限り、上位に渡さない”
                        4. 結果として、
                            - フレーム単位では完成しているのに
                            - TCP単位では未完成
                            - という状態が発生し、アプリに渡せなくなった
                    - HTTP/3ではTCPを捨ててUDPで行う
                        - TCPによる順序保証をなくすことで、より高速な通信を可能にする
                        - UDPは順序保証がない
                        - そのため、パケットの順序を保証するための仕組みが必要
                        - QUICは、ストリーム単位でパケットを送信する仕組みを提供する
                        - これにより、reactでSSRを実装する際に、より高速な通信を可能にする
                        - また、
                            - Alt-Svc: h3=":443"; ma=86400
                            - HTTP/3のサポートを宣言する
                            - ma=86400は、86400秒間有効な宣言
                5. WebSocket
                    - 一度HTTP(1.1以降)でTCP接続を確立した後、websocket通信状態になる
                    - 送る情報がhttpヘッダーなどが送られない分、高速かつ軽量な通信を可能にする
                    - 基本的にはリアルタイム性を重視する際に使用されるため、チャットやゲームなどに使用されることが多い
                        - FPSなどでは常に最新のものが表示され、古い状態のデータは破棄される
                        - これによってキャラクターのワープなどが起こる
                6. gRPC
                    - HTTP/2をベースに、従来の問題を解決するための思想
                        - テキストで冗長
                        - 型が曖昧
                        - パースが遅い
                        - 双方向通信が弱い
                        - エンドポイント乱立
                    - Client → Server1 → Server2 → Server3 のように
                        - サービスが連鎖する構成では、
                        - 「送る／返すデータの型」を事前に厳密に定義しておくことで、
                        - サービス間通信の整合性（型安全性）を担保するのが gRPC の本質
                        - つまり
                            - rpc UpdateUser(UpdateUserRequest) returns (UpdateUserResponse)
                            - という形で、interfaceを意識するだけで、サーバー間の通信意識できるようになった
                        - 基本的には常時接続しているようなサービス間での通信で使用される
                            - 基本的なwebサービスでは使用されない
    - Parse HTML > DOM構築
        - HTMLの構造を理解する(構文解析)
            - 字句解析によるトークンのリスト化
                - トークンとは、構文解析の最小単位で意味的に一つの塊になっている文字列
                - 送られて来るデータ "<html><body><p>Hello</p></body></html>"
                - これを解析することで、
                    - <html>
                    - <body>
                    - <p>
                    - Hello
                    - </p>
                        - StartTagToken(name="p", attributes={class:"msg"})
                        - CharacterToken("H")
                        - CharacterToken("e")
                        - CharacterToken("l")
                        - CharacterToken("l")
                        - CharacterToken("o")   
                        - EndTagToken(name="p")
                    - </body>
                    - </html>
                    - というトークンのリストが生まれる
                - リスト化する理由はHTMLは全部揃わなくてもパースしてストリーミングで表示するため
                - この構文解析は暗黙的な構文補完が行われる。
                    - <div><p>Hello</div>といったデータが来ると
                        - <div>
                        - <p>
                        - Hello
                        - </p>
                        - </div>
                        - という構造が暗黙的に補完され、トークンのリストが生まれる
            - 構文解析による構文木の構築
                - トークンの列を解析することで生まれるツリー構造のデータで、構文木と呼ばれる
                - 上記でリスト化されたデータをの親子関係を構築する
                    - div
                        ├─ p
                        │   └─ "Hello"
                        └─ span
                            └─ "World"
            - 構文木にあるJSを実行しつつ、DOMツリーを構築する
                - <body>
                    <div id="a"></div>
                    <script>
                        document.getElementById("a").textContent = "hello";
                    </script>
                    <p>world</p>
                </body>
                - このデータに対して、
                    - body
                    ├─ div#a (text: "hello")
                    └─ p ("world")
                    - という構造が生まれる
                - htmlを構築中にscriptを逐次実行する
            - 仮想DOM
                - DOMツリーを構築する際に、仮想DOMを構築する
                - 仮想DOMとはtsx側の見た目の概念で
                - tsxなどをbuildすることで、jsに変換する
                - このjsは"document.createElement("div")"のようなjsを生成する
                - このjsからhtmlを生成、jsの実行を経てDOMを構築する
                - この際、静的コンテンツの範囲をより正確に確定させる、静的解析能力が重要になってくる
        - レンダリング内部表現に変換(レンダリングごとに固有の差が生まれる)
        - ここで、DOMツリーが構築されたり、CSSOM(CSSオブジェクトモデル)が構築される
            - CSSOMは、CSSを解析して構文木を構築する
            - Render Tree:
                div
                ├─ p (color: red)
                └─ span (color: blue)
                - という構造が生まれる
            - Render Treeは、DOMツリーとCSSOMを組み合わせたもの
            - そのため、いちいちstyleで記述するよりもcssファイルで共通化した方が、パフォーマンスが良い
2. Scripting
    - JavaScript実行
        - 字句解析
            - トークンのリスト化
        - 構文解析
            - ASTの構築
        - コンパイル
            - コード生成
            - jitによって、マシン語に変換
        - 実行
    - DOM操作
3. Rendering
    - スタイルの計算
        - DOMツリーとCSSOMを組み合わせたもの
        - セレクタがマッチするかを総当たりで検索する(index貼らないのか)
        - DOMが100個あり、CSSが100個あり、
            - 100 * 100 = 10,000
            - これを毎フレーム計算する
        - CSSの解析順は右からになっている
            - body > .container > .itemの場合、
                - DOMのitemclassを持つ要素に対して、
                - containerクラスを持つ要素に対して、
                - bodyクラスを持つ要素に対して、
                - という順で検索する
        - またこの時点で、cssの適応優先度が決定される
            - styleタグの方が優先される
            - !importantの方が優先される(ただし、styleよりも後にある場合、!importantの方が優先される)
            - idの方が優先される
            - classの方が優先される
            - tagの方が優先される
    - レイアウト
        - 要するに要素の大きさを決める
        - paddin, margin, width, height, z-index, flexなどが影響する        
4. Painting(描画)
    - paint
        - レンダリングツリーを描画する
        - 2Dグラフィックスを描画する
    - Rasterize
        - 2Dグラフィックスをピクセル単位で表現する
        - この時点で、z軸の上下を明確に持つようになる
        - positionなどもここで定義している。
        - この際レイヤーという単位で一枚ごとに管理される
            - レイヤーの再描画をスキップするため
            - スクロールして戻るときにちゃんと描画されているのもこれのおかげ
    - Composite Layers(レイヤーの合成)
        - 基本的にはCPUで処理されるが、translate3Dのような関数を使うとGPUで処理される
5. 再レンダリング
    - scriptingから再実行される
    - 全てが再計算されるわけではなく、影響範囲のある箇所だけ変更されるようになっている。